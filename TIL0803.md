# TIL(2일차)
<br>

## **📝2일차 - 자바 OOP 이야기**

 ## 1. 객체지향 프로그래밍

> **Object-Oriented Programming** 의 줄임말<br>
  구조적 프로그래밍 방식의 개선된 형태
  큰 문제를 작게 쪼개는 것이 아니라, 작은 문제들을 해결하는 객체를 만든다.
  객체들을 조합해 **큰 문제를 해결하는 Bottom-Up 방식**

* * *    
### 📍OOP 특징
* 프로그램의 동작을 객체들에게 작게 나눠서 수행
  * 개념적인 용어 : 객체, 기술적인 용어 : class, instance
  * 객체는 서로 구분할 필요가 있다. type(형)
* 코드의 재사용성이 높다.
  * 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성이 가능하다.
* 코드의 관리가 용이하다.
  * 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
* 신뢰성이 높은 프로그래밍을 가능하게 한다.
  * 코드의 중복을 제거하여 코드의 불일치로 인한 오류를 방지 할 수 있다.

<br>

 ## 2. 객체지향(OOP)의 4가지 특성

### **1️⃣ 캡슐화(Encapsulation)**
> 중요한 데이터를 보존하고 보호하는 것.<br>
> SW 공학에서 요구사항 변경에 대처하는 고전적인 설계 원리

- 객체의 필드와 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감춘다.
- 외부 객체는 제공하는 필드와 메소드만 이용할 수 있다.
- 캡슐화는 외부의 잘못된 사용으로 인해 객체가 침해 당하지 않게 한다.
- 노출을 위해 접근 제한자(Access Modifier)를 사용한다.
  * private : 객체 소유.
  * protected : 상속된 객체에서도 접근 가능.
  * **(friendly)** : 같은 패키지 내에서 접근 가능. (패키지 가시성)
  * public : 모두 다 접근 가능. 

### 📍특징
* 높은 응집도와 낮은 결합도를 유지할 수 있도록 설계해야 요구사항을 변경할 때 유연하게 대처할 수 있다.
  1. 응집도(Cohesion)
     * 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.
  2. 결합도(Coupling)
     * 어떤 기능을 실행하는데 다른 클래스나 모듈들이 얼마나 의존적인지를 나타낸다.
* 캡슐화는 **낮은 결합도**를 유지할 수 있도록 해주는 객체지향 설계 원리다. 

  
<br>

### **2️⃣ 상속**
> 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.<br><br>
> 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 좋다.

* 상위, 부모, super, [추상]
* 하위, 자식, (this), [구체]

<br>


### **3️⃣ 추상화(Abstraction)**
> 어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업<br>
> 추상화된 객체 : 추상체<br>
> 구체적인 객체 : 구상체<br>
> 객체관계에서 상위에 있는 것이 항상 하위에보다 추상적이어야 한다.

### 📍특징
* 사물들의 공통된 특징, 즉 추상적 특징을 파악해 인식의 대상으로 삼는 것
* 구체적인 사물들의 공통적인 특징을 파악하여 이를 하나의 개념으로 다루는 수단이다.
* 각 객체의 구체적인 개념에 의존하기 보다 추상적 개념에 의존해야 설계를 유연하게 변경할 수 있다.

``` java
// 의미적 추상체
class Login {
    void login() {}
}

class KakaoLogin extends Login {
    void login() {}
}
```
``` java
// 추상기능을 가진 객체
abstract class Login {
    abstract void login();
}

class KakaoLogin extends Login {
    void kakao() {}
    @Override void login() {}
}
```
``` java
// 객체 자체가 추상적
interface Login {
    void login();
}

class KakaoLogin implements Login {
    void kakao() {}
    @Override void login() {}
}
```
<br>

### **4️⃣ 다형성(Polymorphism)**

> 다형성은 서로 다른 클래스의 객체가 같은 메세지를 받았을때 각자의 방식으로 동작하는 특징이다.

``` java
class KakaoLogin implements Login {
    void kakao() {}
    @Override void login() {}
}

interface Portal {
    void portal();
}

class NaverLogin implements Login, Portal {
    void naver() {}
    @Override void login() {}
    @Override void portal() {}
}

//Main
KakaoLogin k = new KakaoLogin();
Login k = new KakaoLogin();

Login login = new Login();
Login login = new KakaoLogin();
Login login = new NaverLogin();
login.login(); //이것만 쓸 수 있다.
               //kakao, Naver 불가 
Portal potal = new NaverLogin();
potal.portal(); //이것만 쓸 수 있다. 

```
<br>

 ## 3. 객체지향 설계

### **1️⃣ UML**
> UML(Unified Modeling Language)은 도메인을 모델로 표현해주는 대표적인 모델링 언어이다.

* UML은 소프트웨어를 설계하며 필요에 의해서 사용되는데 일반적으로 3가지의 목적이 있다고 한다.
  * 의소소통 또는 설계 논의를 위해
  * 전체 시스템 구조 및 클래스의 의존성을 파악하기 위해
  * 유지보수를 위한 설계의 back-end 문서 제작을 위해

* 4가지 종류 
  * Usecase Diagram
  * Sequence Diagram
  * Package Diagram
  * **Class Diagram** [일반적으로 많이 쓰임]

* Tool(쉽게 만들 수 있다.)
  * https://draw.io
  * https://staruml.io/
  

<br>

### **📍클래스 다이어그램**
> 클래스 다이어그램은 정적 다이어그램으로 클래스의 구성요소 및 클래스간의 관계를 표현하는 대표적인 UML이다.

**참고** : 
https://sabarada.tistory.com/72#recentEntries

<br>

### **2️⃣ 어떻게 하면 객체를 잘 나누고 연관지을 수 있느냐?**

> 객체지향 설계를 하기 위한 5가지 원칙<br>
> 1. S : 단일 책임 원칙(SRP)
> 2. O : 개방-폐쇄 원칙(OCP)
> 3. L : 리스코프 치환 원칙(LSP)
> 4. I : 인터페이스 분리 원칙(ISP)
> 5. D : 의존 역전 원칙(DIP)

<br>
참고 : https://gmlwjd9405.github.io/2018/07/05/oop-solid.html

### **📍디자인 패턴**


**Design Patterns: Elements of Reusable Object-Oriented Software (1994)** 책<br>


(숙제) 23가지 디자인 패턴
<br>
참고(나무위키) : https://namu.wiki/w/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4

요약정리 : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cra2yboy&logNo=220001640887


* 추상 팩토리 ( Abstract Factory, p132 )
  * 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴이다.
<br>
<br>
* 적응자 ( Adapter, p196 )
  * 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 한다.
<br>
<br>
* 가교 ( Bridge, p213 )
  * 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴이다.
<br>
<br>
* 빌더 ( Builder, p144 )
  * 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴이다.
<br>
<br>
* 책임 연쇄 ( Chain of Responsibility, p298 )
  * 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 객체 사이의 결합을 피하는 패턴이다.
  * 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 처리한 객체를 만날 때까지 객체 고리를 따라서 요청을 전달한다.
<br>
<br>
* 명령 ( Command, p311 )
  * 요청을 객체의 형태로 캡슐화하여, 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패턴이다.
<br>
<br>
* 복합체 ( Composite, p226 )
  * 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 한다.
<br>
<br>
* 장식자 ( Decorator, p241 )
  * 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다.
<br>
<br>
* 퍼사드 ( Facade, p254 )
  * 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의한다.
<br>
<br>
* 팩토리 메서드 ( Factory Method, p156 )
  * 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴이다.
  * 팩토리 메소드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룬다.
<br>
<br>
* 플라이급 ( Flytweight, p265 )
  * 크기가 작은객체가 여러개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴이다.
<br>
<br>
* 해석자 ( Interpreter, p324 )
  * 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴이다.
<br>
<br>
* 반복자 ( Iterator, p340 )
  * 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴이다.
<br>
<br>
* 중재자 ( Mediator, p359 )
  * 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정의하는 패턴이다.
  * 객체들이 직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합( loose coupling )을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만든다.
<br>
<br>
* 메멘토 ( Memento, p371 )
  * 캡슐화를 위배하지 않는 채 어떤 객체의 내부 상태를 잡아내고 신체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴이다.
<br>
<br>
* 감시자 ( Observer, p382 )
  * 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴이다.
<br>
<br>
* 원형( Prototype, p169 )
  * 생성할 객체의 종류를 명세화하는 데에 원형이 되는 예시물을 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴이다.
<br>
<br>
* 프록시 ( Proxy, p279 )
  * 어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자( surrogate ), 또는 자리채움자( placeholder )를 제공하는 패턴이다.
<br>
<br>
* 단일체 ( Singleton, p181 )
  * 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴이다.
<br>
<br>
* 상태 ( State, p395 )
  * 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것 처럼 보인다.
<br>
<br>
* 전략 ( Strategy, p407 )
  * 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도 록 만드는 패턴이다.
  * 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 한다.
<br>
<br>
* 템플릿 메소드 ( Template Method, p419 )
  * 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴이다.
  * 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서 재정의할 수 있게 한다.
<br>
<br>
* 방문자 ( Visitor, p426 )
  * 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 한다.
