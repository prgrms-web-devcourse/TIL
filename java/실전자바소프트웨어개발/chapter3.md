# 3장

3장에서는 이러한 것들을 배운다.

- 코드에 유연성을 추가하고 유지보수성을 개선하는 데 도움을 주는 `개방/폐쇄 원칙(OCP)`
- `언제 인터페이스를 사용하면 좋을지`를 설명하는 일반적인 가이드라인과 `높은 결합도를 피할 수 있는 기법`
- 언제 API에 예외를 포함하거나 포함하지 않을지를 결정하는 자바의 `예외 처리 방법`
- 검증된 `빌드 도구`(Maven, Gradle)를 이용해 자바 프로젝트를 시스템적으로 빌드하는 방법

## 추가된 입출금 내역 분석기 요구 사항

1. 특정 입출금 내역을 검색할 수 있는 기능. 예를 들어 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기.
2. 검색 결과의 요약 통계를 text, HTML 등 다양한 형식으로 만들기.

## 개방/폐쇄 원칙

> **코드 중복 문제**
>
> 중복 코드는 소프트웨어를 불안정하게 만드는데, 특히 요구 사항이 자주 바뀔수록 영향이 커진다.

특정 여러 조건으로 입출금 내역 검색을 코드 중복으로 여러개의 매서드를 구현하는 경우 다음과 같은 문제가 발생한다.

- 여러 속성을 조합할수록 코드가 점점 복잡해진다.
- 반복 로직과 비즈니스 로직이 결합되어 분리하기 어려워진다.
- 코드를 반복한다.

계방/폐쇄 원칙을 적용하면 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다. 인터페이스를 이용해 반복 로직과 비즈니스 로직의 결합을 제거할 수 있다.

> **함수형 인터페이스**
>
> 한 개의 추상 메서드를 포함하는 인터페이스.<br/> `@FunctionalInterface` Annotation을 이용하면 인터페이스의 의도를 더 명확하게 표현할 수 있다.

- 새로운 인터페이스를 이용해 반복 로직과 비지니스 로직의 결합을 제거하는 과정이므로 이는 상당히 중요한 리팩터링이다.
  - 왜? 기존 메서드의 바디를 바꿀 필요 없이 새로운 구현을 인수로 전달하기 때문.
- 변경 없이도(**closed**) 확장성은 개방(**open**)된다.
- 이런 방식으로 기능을 확장하면 기존에 이미 구현하고 검증한 코드를 바꾸는 일을 최소화할 수 있으므로 새로운 _버그가 발생할 만한 대상을 줄일 수 있다_.

### 람다 표현식

- 함수형 인터페이스 인스턴스로 만들면 새로운 요구 사항이 있을 때마다 별도의 클래스를 만들어야한다.
- 자바8 부터 **람다 표현식**과 **메서드 레퍼런스**를 사용하여 이름 없는 인터페이스 구현 객체를 코드 블록 형태로 전달할 수 있다.
- 장점
  1. 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
  2. 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
  3. 결합도가 낮아지므로 코드 유지보수성이 좋아진다.

## 인터페이스 문제

한 인터페이스에 모든 기능을 추가하는 갓 인터페이스(God Interface)를 만드는 일은 피해야한다.

### God Interface

구현해야 할 모든 기능을 인터페이스에 정의하면 생기는 문제점

- 모든 헬퍼 연산이 명시적인 API 정의에 포함되면서 인터페이스가 복잡해진다.
- 갓 클래스와 비슷한 갓 인터페이스가 만들어진다.
  - 자바의 인터페이스는 모든 구현이 지켜야할 규칙을 정의하고 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야 한다. **인터페이스를 바꾸면 이를 구현한(implement) 코드도 바뀐 내용을 지원하도록 갱신되어야 하므로** 문제가 발생할 수 있는 범위도 넓어진다.
  - 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생기면 도메인 객체의 세부내용이 바뀜에 따라 인터페이스 코드도 바뀌어야 하는 문제점이 발생한다.

### 지나친 세밀함

지나치게 인터페이스가 세밀해도 코드 유지보수에 방해가 된다.
기능이 여러 인터페이스로 분산되므로 필요한 기능을 찾기가 어려운 **안티 응집도** 문제가 발생한다.

## 명시적 API vs 암묵적 API

구체적으로 메서드를 정의해야 하는지 의문이 생기는 딜레마를 `명시적 API vs 암묵적 API 제공 문제`라고 부른다.

1. 명시적 API

- 장점
  - 어떤 동작을 수행하는지 잘 설명되어 있고, 사용하기 쉽다.
- 단점
  - 이 메서드의 용도가 특정 상황에 국한되어 각 상황에 맞는 새로운 메서드를 많이 만들어야 하는 상황이 벌어진다.

2. 암묵적 API

- 장점
  - 거래 내역을 검색하는 데 필요한 모든 상황을 단순한 API로 처리할 수 있다.
- 단점
  - 처음 사용하기 어렵고, 문서화를 잘해놓아야 한다.

3. 그래서 어떤것을 사용해야하는데?

- 딱히 정답은 정해져 있지 않다. (질문의 종류에 따라 달라질 수 있음.)
- 명시적 API가 가장 흔히 사용하는 연산이라면 사용자가 쉽게 이해하고 사용하도록 만드는 것이 합리적인 방법.

### 도메인 클래스 vs 원싯값

인터페이스를 원시값으로 결과값을 반환하면 생기는 문제점

- 원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어진다.

해결방법

- 원시값(primitive type)을 감싸는 새 도메인 클래스(ex Summary)를 만들면 필요한 필드와 결과를 언제든 추가하여 해결할 수 있다.
- 이 기법을 이용하면 도메인의 다양한 개념간의 결합을 줄이고, 요구 사항이 바뀔 때 연쇄적으로 코드가 바뀌는 일도 최소화할 수 있다.

## 다양한 형식으로 내보내기

위의 요구사항 중 요약 통계를 다양한 형식으로 내보내기 위해 개방/폐쇄 원칙과 인터페이스를 사용하여 처리해보자.

### 도메인 객체 소개

다음과 같은 형식으로 내보내면 좋은 장단점

- 숫자
  - 장점
    - 간단하게 구현
  - 단점
    - 요구사항이 바뀔 때 유연하게 대처 못함. -> 버그 발생 큼
- 컬렉션
  - 장점
    - Iterable을 반환하면 상황에 맞춰서 처리하기 때문에 유연성이 좋아짐.
  - 단점
    - 오직 컬렉션만 반환해야 한다는 제약이 따라서 다양한 종류의 결과를 반화하기가 힘들다.
- 특별한 도메인 객체
  > 도메인 객체란
  >
  > - 자신의 도메인과 관련된 클래스의 인스턴스이다.
  - 장점
    - 도메인 객체를 이용하면 **결합을 느슨하게** 하여 새로운 요구 사항이 생겨서 추가 정보를 내보내야 한다면 기존 코드를 바꿀 필요 없이 새로운 클래스의 일부로 이를 구현할 수 있다.
  - 단점
    - ??
- 더 복잡한 도메인 객체
  - 장점
    - 다양한 결과를 저장하는 필드를 포함하는 개념을 만들 수 있다.
      - ex. Summary 도메인 객체 안에 Report 와 같은 거래 내역 컬렉션을 추가
      - 어떤 상황이든 Report 객체를 생산하는 부분과 이를 소비하는 부분이 서로 결합하지 않는다는 큰 장점. ~~(? 모지 몬말이지)~~

### 적절하게 인터페이스를 정의하고 구현하기

내보낼 형식이 무엇인지 파악했으므로 이를 구현하는 API가 필요하다. 인터페이스를 정의하여 다양한 내보내기 구현 코드가 다른 코드와 결합하지 않도록 방지한다. (*개방/폐쇄 원칙*으로 연결됨.)

```java
public interface Exporter {
  void export(SummaryStatistics summaryStatistics);
}
```

- 인터페이스의 나쁜 예
  - void 반환 형식은 아무 도움이 되지 않고, 기능을 파악하기도 어렵다.
  - void를 반환하면 Assertion으로 결과를 테스트하기도 매우 어렵다.

## 예외 처리

### 예외를 사용해야 하는 이유

`if` 조건을 추가하여 예외처리하면 어떤 문제점이 있을까?

- 전역으로 공유된 가변 상태에 의존해 최근에 발생한 오류를 검색해야 한다.
- 코드 부분이 따로 분리되어 이해하기가 어려워진다.
- 결과적으로 유지보수가 어렵다.
- 어떤 값이 실제 값인지 아닌지 아니면 오류를 가리키는 값인지 구분하기 어렵다.
  - 강력한 형식 시스템이 있었다면 이 문제를 해결하는 데 조금이나마 도움이 되었을 것.
- 제어 흐름이 비지니스 로직과 섞이면서 코드를 유지보수하거나 프로그램의 일부를 따로 테스트하기도 어려워진다.

자바는 예외를 일급 언어 기능으로 추가하고 다음과 같은 장점을 제공.

- 문서화 : 메서드 시그니처 자체에 예외를 지원.
- 형식 안정성 : 개발자가 예외 흐름을 처리하고 있는지를 형식 시스템이 파악한다.
- 관심사 분리 : 비즈니스 로직과 예외 회복(recovery)이 각각 `try/catch` 블록으로 구분된다.

하지만 다음과 같은 단점이 존재

- 복잡성이 증가한다는 단점

자바는 두 가지 종류의 예외를 지원

- 확인된 예외
  - 회복해야 하는 대상의 예외. 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 한다. 아니면 해당 예외를 `try/catch` 로 처리해야 한다.
- 미확인 예외
  - 프로그램을 실행하면서 언제든 발생할 수 있는 종류의 예외이다.
    ![자바의 예외 계층도](http://tcpschool.com/lectures/img_java_exception_class_hierarchy.png)

### 예외의 패턴과 안티 패턴

- 미확인 예외와 확인된 예외에서 선택하는 방법
  - 프로그램이 회복되도록 강제할 것인지를 스스로 생각해보면 답이 나온다.
  - 보통 비즈니스 로직 검증(잘못된 형식이나 연산) 시 발생한 문제는 불필요한 try/catch 구문을 줄일 수 있도록 미확인 예외로 결정한다.
  - 예외가 발생하고 어떻게 회복할지 애매한 상황에서, API 사용자에게 오류를 복구하라고 강제할 필요가 없다.
    - 시스템 오류도 미확인 예외로 지정한다.
  - **즉, 대다수의 예외를 미확인 예외로 지정하고 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드를 줄여야 한다.**

### 과도하게 세밀함 vs 과도하게 덤덤함

- 전용 `Validator` 클래스를 만드는 것을 권고.
  1. 검증 로직을 재사용해 코드를 중복하지 않는다.
  2. 시스템의 다른 부분도 같은 방법으로 검증할 수 있다.
  3. 로직을 독립적으로 유닛 테스트할 수 있다.
  4. 이 기법은 프로그램 유지보수와 이해하기 쉬운 `SRP`를 따른다.
- **과도하게 세밀함**
  - 장점
    - 이 방법을 적용하면 각각의 예외에 적합하고 정확한 회복 기법을 구현 할 수 있다.
  - 단점
    - 너무 많은 설정 작업이 필요하고, 여러 예외를 선언해야 하며, 사용자가 이 모든 예외를 처리해야 하므로 생산성이 현저하게 떨어진다.
    - 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.
- **과도하게 덤덤함**
  - 모든 예외를 미확인 예외로 지정하는 극단적인 상황
  - 단점
    - 구체적인 회복 로직을 만들 수 없는 문제점.
    - 마찬가지로 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.
- **해결방법**

  - 과도한 세밀함과 과도한 덤덤함에서 발생한 문제를 해결하는 `Notification Pattern`을 알아보자.

- **Notification Pattern**
  - 너무 많은 미확인 예외를 사용하는 상황에 적합한 해결책을 제공. 도메인 클래스로 오류를 수집한다.

### 예외 사용 가이드라인

- 예외를 무시하지 않음
  - 문제의 근본 원인을 알 수 없다고 예외를 무시하면 안 된다.
- 일반적인 예외는 잡지 않음
  - 가능한 구체적으로 예외를 잡으면 가독성이 높아지고 더 세밀하게 예외를 처리할 수 있다.
- 예외 문서화
  - API 수준에서 미확인 예외를 포함한 예외를 문서화하므로 API 사용자에게 문제 해결의 실마리를 제공한다.
- 특정 구현에 종속된 예외를 주의할 것
  - 특정 구현에 종속된 예외를 던지면 API의 캡슐화가 깨지므로 주의하자.
- 예외 vs 제어 흐름
  - 예외로 흐름을 제어하지 않는다.

### 예외 대안 기능

예외를 대체할 수 있는 기능??

- null 사용
  - 예외를 던지지않고 null을 반환하면 NullPointerException이 발생할 수 있으며 불필요한 디버깅에 시간이 소비된다.
- null 객체 패턴
  - 종종 null 객체 패턴을 사용하는데, 객체가 존재하지 않을 때 null 레퍼런스를 반환하는 대신에 필요한 인터페이스를 구현하는 개체(바디는 비어 있음)를 반환하는 기법이다.
  - 장점
    - 의도하지 않는 NullPointerException과 긴 null 확인 코드를 피할 수 있다는 점이 null 객체 패턴의 강점
  - 단점
    - 데이터에 문제가 있어도 빈 객체를 이용해 실제 문제를 무시할 수 있어 나중에 문제를 해결하기가 더 어려워질 수 있다.
- `Optional<T>`
  - 자바 8에서 값이 없는 상태를 표현하는 내장 데이터 형식인 `java.util.Optional<T>`를 제공하여 값이 없는 상태를 명시적으로 처리하여 버그의 범위를 줄이는 데 큰 도움이 왼다.
- `Try<T>`
  - 성공하거나 실패할 수 있는 연산을 가리키는 `Try<T>` 데이터 형식도 있음
  - 값이 아니라 **연산**에 적용할 수도 있음.
  - 외부 라이브러리를 사용해야함.

## 빌드 도구 사용

### 왜 사용하나요?

- 프로젝트에 적용되는 공통적인 구조를 제공하기 때문에 협업 편리
- 빌드하고 실행하는 반복적이고, 표준적인 작업을 설정
- 저수준 설정과 초기화에 들이는 시간을 절약하므로 개발에만 집중
- 잘못된 설정이나 일부 빌드 과정 생략 등으로 발생하는 오류의 범위를 줄임
- 공통 빌드 작업을 재사용해 이를 다시 구현할 필요가 없으므로 시간을 절약.

### 메이븐 사용

- XML 기반으로 빌드 과정을 정의
- 큰 커뮤니티가 저장소를 관리하고 있어 든든
- `pom.xml`

### 그레들 사용

- 메이븐의 프로젝트 구조 표준화 등 여러 유용한 아이디어를 적용한 부분을 계승
- 그루비, 코틀린 프로그래밍 언어 등을 이용ㅇ해 친근한 도메인 특화 언어(Domain Specific Language)를 적용한다는 점.
  - 결과적으로 더 자연스럽게 빌드를 지정
  - 쉽게 커스터마이즈할 수 있으며 쉽게 이해가능
  - `build.gradle`, `settings.gradle`

<br/>
<br/>
<hr/>
<br/>
<br/>

## 더 공부해야할 부분

- [ ] 함수형 인터페이스
- [ ] Predicate<T> 제네릭 인터페이스
- [ ] 람다표현식
- [ ] 메서드 레퍼런스
- [ ] 도메인 객체 (복잡한 예시)
- [ ] 일급 언어
- [ ] 자바의 형식 시스템
- [ ] 메서드 시그니처?
- [ ] Domain Specific Language?
