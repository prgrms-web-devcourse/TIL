# 1장

1장에서는 간단하게 책에서 사용하는 개념과 원칙을 소개한다. (자바, 소프트웨어 디자인과 아키텍처, SOLID 및 테스트)

<hr/>

# 2장

2장에서는 [입출금 내역을 자동으로 분석해 재정상태를 더 잘보여주는 소프트웨어](./BankTransactionAnalyzerSimple.java)를 개발하면서 좋은 소프트웨어 개발의 기반이 무엇인지 배운다.

### KISS 원칙

- KISS(Keep In Short and Simple) : 소프트웨어 디자인을 간단하고 단순하게 하는 것.
  - 일단 응용프로그램 코드를 한 개의 클래스로 구현함.
- 문제점 (예외 사항)

  - _파일이 비어 있다면?_
  - _데이터에 문제가 있어서 금액을 파싱하지 못 한다면?_
  - _행의 데이터가 완벽하지 않다면?_

  > 언제나 이런 질문을 하는 습관을 가지는 것이 좋음

- +) final 변수
  - 코드에 가능한 많은 변수를 final로 표시하면 어떤 객체의 상태가 바뀔 수 있고, 어떤 객체의 상태가 바뀔 수 없는지 명확하게 구분할 수 있다.
  - final 키워드가 쓸모없는 상황 : 추상메서드의 메서드 파라미터에 final을 사용하는 상황에서는 실제 구현이 없으므로 final 키워드의 의미가 무력화됨.

### 코드 유지보수성과 안티 패턴

사용했던 코드를 복붙하면 좋은 방법일까용? ㄴㄴ

- 코드 유지보수성
  - 일단 구현하는 코드가 가졌으면 하는 속성 목록을 만들어 본다.
    1. 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 한다.
    2. 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 한다.
    3. 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 한다.
    4. 캡슐화가 잘 되어 있어야 한다. 즉 코드 사용자에게는 세부 구현 내용이 감춰져 있으므로 사용자가 쉽게 코드를 이해하고, 기능을 바꿀 수 있어야 한다.
- 궁극적으로 개발자의 목표는 현재 만들고 있는 응용프로그램의 복잡성을 관리하는 것이다.

  - 새로운 요구 사항이 생길때 마다 **복붙**으로 해결한다면 *다음과 같은 문제*가 발생하며, 이를 **`안티 패턴`**(Anti-Pattern)이라고 부른다.
    - 문제 1. 한 개의 거대한 **갓 클래스**(God Class) 때문에 코드를 이해하기 어렵다.
    - 문제 2. **코드 중복**때문에 코드가 불안정하고 변화에 쉽게 망가진다.

- 갓 클래스

  - 갓 클래스 안티 패턴 : 한 클래스로 모든 것을 해결하는 패턴
  - 이는 `단일 책임 원칙`으로 코드를 쉽게 이해하고 유지보수할수 있도록 구현을 해본다.

- 코드 중복
  - 여러 곳에 코드가 중복되어 있으면 기존의 기능을 바꾸기 어려워지고 결과적으로 모든 곳의 코드를 다 빠궈야 하며, 새로운 버그가 발생할 가능성이 커짐.
    > DRY(Dont't Repeat Yourself)
    >
    > - 하나의 기능을 한 곳에 두자.
    > - 반복되는 공통부분을 추상화하여 한곳에 모으고 그곳을 참조하게 함
    > - 반복을 제거하면 로직을 바꿔도 여러곳의 코드를 바꿔야 할 필요성이 없어진다.
  - 한 문제를 작은 개별 문제로 분리해 더 쉽게 관리할 수 있는지 파악하여 더 이해하기 쉽고, 쉽게 유지보수하며, 새로운 요구 사항도 쉽게 적용하는 결과물을 만들 수 있도록 한다.

### 단일 책임 원칙 (SRP)

- SRP : 쉽게 관리하고 유지보수하는 코드를 구현하는데 도움을 주는 포괄적인 소프트웨어 개발 지침

  - **두 가지**를 보완하기 위해 SRP를 적용 한다.
    - 한 클래스는 한 기능만 책임진다.
    - 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다. (로버트 마틴)
  - SRP를 적용하면 코드가 바뀌어야 하는 이유가 한 가지로 제한되므로 더 튼튼한 코드를 만들 수 있음.
  - 이유가 한가지가 아니라면, 여러 장소에서 코드 변경이 발생하므로 코드 유지보수가 더 어려워 진다.

- 놀람 최소화 원칙(Principle of least surprise)
  - 메서드를 구현할 때는 놀람 최소화 원칙을 따라야한다. 그래야 코드를 보고 무슨 일이 일어나는지 명확하게 이해할 수 있기 때문. (일관성을 유지하는 범위에서 코드를 구현할 것을 강조하는 원칙)
  - 다음을 참고
    - 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명을 사용한다.
    - 코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로 파라미터의 상태를 바꾸지 않는다.

### 응집도

- **`응집도`** 는 코드 구현에서 가장 중요한 특성으로 **서로 어떻게 관련되어 있는지**를 가르킨다.
  - 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정
  - 소프트웨어의 복잡성을 유추하는데 도움을 준다.
  - 클래스에 적용하지만, 메서드에도 적용할 수 있다.
- 클래스 수준 응집도는 여섯가지 방법으로 그룹화한다.
  1. 기능
     - 기능이 비슷한 메서드를 그룹화
     - 찾기도 쉽고 이해하기뒤 쉬우므로 응집도를 높임
     - 하지만 과도하게 만들면 클래스가 많아지며 코드가 장황해지고 복잡해짐
  2. 정보
     - 같은 데이터나 도메인 객체를 처리하는 메서드를 그룹화하는 방법이 있다. (eg. BankTransaction)
     - 정보 응집은 여러 기능을 그룹화하면서 필요한 일부 기능을 포함하는 클래스 전체를 디팬던시로 추가한다는 약점이 있다.
       > 데이터 접근 객체(Data Access Object)
       >
       > - 테이블이나 특정 도메인 객체를 저장하는 데이터베이스와 상호작용할 때 흔히 볼 수 있다. (eg. Entity, Model)
       > - 객체를 식별하는 일종의 ID가 필요하다.
       > - DAO는 연구 저장 데이터베이스나 인메모리 데이터베이스 같은 데이터 소스로의 접근을 추상화하고 캡슐화한다.
  3. 유틸리티
     - 때로는 관련성이 없는 메서드를 한 클래스로 포함시켜야 하는데 어디에 속해야할지 결정하기 어려울 때는 만능 **유틸리티 클래스**에 추가하기도 한다.
     - 하지만 유틸리티 클래스 사용은 낮은 응집도로 이어지므로 자제해야한다.
  4. 논리
     - 높은 응집도를 유지하면서 다양한 기능을 구현하려면 `결합도`를 사용한다.
  5. 순차
     - 입출력이 순차적으로 흐르는 것을 `순차 응집`이라고 한다.
     - `순차 응집`은 여러 동작이 어떻게 함께 수행되는지 쉽게 이해할 수 있다.
     - 순차 응집을 적용하면 한 클래스를 바꿔야 할 여러 이유가 존재하므로 SRP를 위배한다. 결국 이 기법은 클래스를 순식간에 복잡하게 만든다.
     - 따라서 각 책임을 개별적으로 응집된 클래스로 분리하는 것이 더 좋은 방법이다.
  6. 시간
     - 시간 응집 클래스는 여러 연산 중 **시간과 관련된 연산**을 그룹화한다.
- 메서드 수준 응집도
  - 응집도 원칙은 클래스 뿐만 아니라 메서드에도 적용할 수 있다.
  - 응집도가 낮은 메서드는 여러 책임을 포함하기 때문에 각 책임을 테스트하기가 어렵고, 메서드의 책임도 테스트하기 어렵다.
  - if / else 블록이 여러 개 포함되어 있다면, 이는 응집도에 문제가 있음을 의미하므로 응집도가 높은 더 작은 조각으로 메서드를 분리해야 한다.

### 결합도

- 응집도는 클래스, 패키지, 메서드 등의 동작이 얼마나 관련되어 있는가를 가리키는 반면, **결합도는 한 기능이 다른 클래스에 얼마나 의존하고 있는지를 가늠한다.**
- 결합도는 어떤 클래스를 구현하는 데 얼마나 많은 지식 (다른 클래스)을 참조했는가로 설명할 수 있다.
  - 더 많은 클래스를 참조했다면 기능을 변경할 때 그만큼 유연성이 떨어진다.
  - 예시로, 시계 내부 구조를 바꾸더라도 사람이 시계를 읽는 데 영향을 받지 않는다. 이는 두 가지 임무인 인터페이스와 구현이 서로 결합되지 않았기 때문.
- 보통 코드를 구현할 때는 `결합도를 낮춰야(low coupling)` 한다. 이는 코드의 다양한 컴포넌트가 내부와 세부 구현에 의존하지 않아야 함을 의미한다. 반대로 `높은 결합도(high coupling)`은 무조건 해야 한다.

### 테스트

- 테스트 자동화의 장점
  - 확신 : 요구 사항을 충족하고 있다는 사실을 더욱 확신할 수 있고 고객에게 증거로 제공할 수 있음.
  - 변화에도 튼튼함 유지 : 바꾼 코드로 인해 새로운 버그가 발생하지 않았음을 확인하는 데 큰 도움이 된다.
  - 프로그램 이해도 : 다양한 컴포넌트가 어떻게 동작하는지 또 어떻게 상호작용하는지를 명확하게 알 수 있다. 새 프로잭트에 투입되었다면 다양한 컴포넌트의 개요를 자동화된 테스트부터 살펴보면 좋다.
- 제이유닛(JUnit) 사용하기
  - 유닛 테스트(Unit Test)
    - 메서드나 작은 클래스처럼 작고 고립된 단위(유닛)를 테스트하는 방법
    - 테스트 코드를 어느 위치에 구현해야하는가?
      - `src/main/java`에 코드를 저장하고 `src/test/java`에 테스트 클래스를 저장하는 것이 기본 규칙
      - JUnit 라이브러리를 디펜던시로 추가해야 한다.
    - 테스트 메서드 정의하기
      - 테스트 클래스는 `Test₩라는 접미어(꼬리)를 포함한다. 개발자에게 이 클래스가 어떤 클래스인지 힌트를 주기도 한다.
      - 테스트 메서드의 구현 코드를 보지 않고도 무엇을 테스트하는지 쉽게 알 수 있도록 서술적인 이름을 붙이는 것이 좋다.
      - JUnit의 애너테이션인 `@Test`를 테스트 메서드에 추가한다. 이 애너테이션으로 해당 메서드가 유닛테스트의 실행 대상임을 지정한다.
      - JUnit에서 제공하는 여러 여러 assertion 연산을 이용해 유닛 테스트를 구현한다.
  - Assert 구문
    - JUnit은 특정 조건을 테스트하는 다양한 Assert 구문을 제공한다. Assert 구문으로 어떤 연산의결과와 여러분이 예상한 결과를 비교할 수 있다.
    - 어서션 구문 사용하면 세 가지 일이 일어난다.
      1. 테스트의 콘텍스트를 설정한다.
      2. 동작을 실행한다.
      3. 예상된 결과를 어서션으로 지정한다.
    - 이와 같은 유닛 테스트 설정의 세 단계 패턴을 **`Given`-`When`-`Then`** 공식이라고 부른다.
- 코드 커버리지
  - 코드 커버리지는 테스트 집합이 소프트웨어의 소스코드를 얼마나 테스트했는가를 가리키는 척도이다. (그래서 커버리지를 높이는 것을 목표로 삼아야 한다.)
  - 코드 커버리지가 높다고 해서 여러분이 소프트웨어를 잘 테스트하고 있음을 의미하는 것은 아니다. 실제 문제가 많이 발생하는 상황을 테스트하지 않을 수도 있기 때문이다.
  - JAVA에서는 `JaCoCo`, `Emma`, `Cobertuna` 같은 코드 커버리지 도구를 많이 사용한다.
  - 많은 구문의 코드를 커버했는지를 의미하는 **`구문 커비리지`**(line Coverage)
    - 분기문(if, while, for)을 한 구문으로 취급해버리는 치명적인 약점이 있다.
  - 따라서 구문 커버리지보다 각 분기문을 확인하는 **`분기 커버리지`**(Branch Coverage)를 사용하는 것이 좋다.
